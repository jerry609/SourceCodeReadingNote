# 反模式识别 (Anti-Patterns)

> 知道什么不能做，比知道什么能做更重要。
> 反模式往往是"局部最优"的诱惑，却导致"全局灾难"。

## 反模式分类

- **架构反模式**: 影响系统整体结构
- **代码反模式**: 影响可维护性和可读性
- **并发反模式**: 导致竞态、死锁
- **性能反模式**: 导致性能问题
- **安全反模式**: 引入安全漏洞

---

## 反模式清单

| 编号 | 反模式名称 | 类型 | 严重程度 | 发现位置 |
|:-----|:-----------|:-----|:---------|:---------|
| AP-1 | ... | 架构 | 高/中/低 | `path/to/` |
| AP-2 | ... | 并发 | 高/中/低 | `path/to/` |

---

## Anti-Pattern 1: [名称]

### 描述

*这个反模式是什么？表现形式？*

### 代码示例

```go
// ❌ 反模式代码
func badExample() {
    // 问题代码...
}
```

### 为什么是反模式？

*这样做会导致什么问题？*

- 问题 1: ...
- 问题 2: ...

### 正确做法

```go
// ✅ 推荐做法
func goodExample() {
    // 正确代码...
}
```

### 检测方法

- [ ] 静态分析规则
- [ ] Code Review Checklist
- [ ] 运行时检测

### 重构建议

*如果已存在这个反模式，如何重构？*

*发现位置*: `path/to/file:line`

---

## Anti-Pattern 2: [名称]

...

---

## 常见反模式参考

### 架构层面

| 反模式 | 描述 | 风险 | 解决方案 |
|:-------|:-----|:-----|:---------|
| 大泥球 (Big Ball of Mud) | 没有清晰架构，随意耦合 | 难以维护和演进 | 模块化重构 |
| 分布式单体 | 微服务但强耦合 | 失去微服务优势 | 定义清晰边界 |
| 上帝对象 | 一个类/模块做太多事 | 难以测试和修改 | 单一职责拆分 |
| 循环依赖 | A→B→C→A | 难以理解和部署 | 依赖反转 |
| 过度工程 | 为假设需求设计 | 增加复杂度 | YAGNI 原则 |

### 并发层面

| 反模式 | 描述 | 风险 | 解决方案 |
|:-------|:-----|:-----|:---------|
| 双重检查锁定 | 错误的懒加载实现 | 竞态条件 | sync.Once |
| 忙等待 | 循环检查条件 | CPU 浪费 | Channel/Cond |
| 锁泄漏 | 异常路径未释放锁 | 死锁 | defer unlock |
| 过度同步 | 不必要的锁 | 性能下降 | 分析竞争点 |

### 数据层面

| 反模式 | 描述 | 风险 | 解决方案 |
|:-------|:-----|:-----|:---------|
| 多写者无协调 | 多处写同一数据 | 数据不一致 | 单一写入点 |
| 缓存不一致 | 缓存与源数据不同步 | 读取脏数据 | 失效策略 |
| N+1 查询 | 循环中查询 | 性能问题 | 批量查询 |
| 宽事务 | 事务持有时间长 | 锁竞争 | 缩小事务范围 |

### API 层面

| 反模式 | 描述 | 风险 | 解决方案 |
|:-------|:-----|:-----|:---------|
| 接口过于宽泛 | 暴露过多细节 | 难以演进 | 最小接口 |
| 隐式契约 | 依赖未文档化行为 | 升级破坏 | 显式契约 |
| 版本地狱 | 太多活跃版本 | 维护成本 | 严格弃用 |
| 无版本 API | API 变更无版本 | 客户端破坏 | 版本化 |

---

## 检测工具

### 静态分析

| 工具 | 检测反模式 | 配置位置 |
|:-----|:-----------|:---------|
| golangci-lint | 代码风格、潜在 bug | `.golangci.yml` |
| go vet | 可疑代码 | 内置 |
| staticcheck | 性能、正确性 | `staticcheck.conf` |

### 运行时检测

| 方法 | 检测内容 | 实现 |
|:-----|:---------|:-----|
| Race Detector | 数据竞争 | `go test -race` |
| Profiling | 性能问题 | pprof |
| Tracing | 调用链问题 | OpenTelemetry |

---

## Code Review Checklist

### 架构检查

- [ ] 是否有循环依赖？
- [ ] 模块职责是否单一？
- [ ] 依赖方向是否正确？

### 并发检查

- [ ] 共享状态是否有保护？
- [ ] 锁是否有 defer 释放？
- [ ] 是否有死锁风险？

### 数据检查

- [ ] 数据修改是否有单一入口？
- [ ] 缓存是否有失效机制？
- [ ] 事务范围是否最小？

### API 检查

- [ ] 接口是否最小化？
- [ ] 变更是否向后兼容？
- [ ] 是否有版本标识？

---

## 重构优先级

| 反模式 | 影响范围 | 修复难度 | 优先级 |
|:-------|:---------|:---------|:-------|
| ... | 全局/局部 | 高/中/低 | P0/P1/P2 |

---

## 预防措施

### 设计阶段

- Design Review 检查清单
- 架构决策记录 (ADR)

### 开发阶段

- CI 集成静态分析
- Code Review 强制检查

### 运维阶段

- 监控异常指标
- 定期架构审查
