# 真相之源分析 (Source of Truth Analysis)

> 系统里最危险的 bug 往往是：两个组件都觉得自己说了算。
> 每一条数据，都必须有且只有一个真相之源。

## 核心原则

1. **唯一权威**: 每条数据只有一个写入点
2. **单向数据流**: 从源头流向消费者，不能反向
3. **派生数据明确标记**: 缓存、索引、视图都是派生的
4. **冲突时以源为准**: 派生数据可以重建

---

## 数据分类

```
┌─────────────────────────────────────────────────────────────┐
│                     Source of Truth                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  配置数据    │  │  业务数据    │  │  元数据             │ │
│  │ (用户定义)   │  │ (系统生成)   │  │ (系统状态)          │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            │
            ┌───────────────┼───────────────┐
            ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   Derived Data   │ │   Derived Data   │ │   Derived Data   │
│   (缓存)         │ │   (索引)         │ │   (聚合视图)     │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

---

## 真相之源清单

| 数据 | 真相之源 | 存储位置 | 写入者 | 派生数据 |
|:-----|:---------|:---------|:-------|:---------|
| 用户配置 | API Server | etcd | 用户 | 本地缓存 |
| 节点状态 | Node Agent | Node Agent | Node Agent | API Server 中的副本 |
| 任务状态 | Controller | etcd | Controller | UI 展示 |

---

## Source of Truth 1: [数据名称]

### 基本信息

| 属性 | 值 |
|:-----|:---|
| 数据描述 | ... |
| 真相之源 | 组件名称 |
| 存储位置 | etcd / DB / 文件 |
| 写入者 | 谁可以写 |
| 读取者 | 谁需要读 |

### 数据流向

```
┌──────────┐     写入      ┌──────────┐     同步      ┌──────────┐
│  写入者   │─────────────▶│  真相源   │─────────────▶│  消费者   │
└──────────┘              └──────────┘              └──────────┘
                               │
                               │ 派生
                               ▼
                         ┌──────────┐
                         │   缓存    │
                         └──────────┘
```

### 派生数据

| 派生数据 | 位置 | 同步机制 | 一致性级别 | 重建方式 |
|:---------|:-----|:---------|:-----------|:---------|
| 本地缓存 | 内存 | Watch | 最终一致 | 重新 List |
| 索引 | DB | 事件驱动 | 最终一致 | 全量重建 |

### 一致性保证

**写入保证**:
- [ ] 原子写入
- [ ] 版本控制 (乐观锁)
- [ ] 冲突检测

**读取保证**:
- [ ] 读自己写 (Read Your Writes)
- [ ] 单调读 (Monotonic Reads)
- [ ] 因果一致性 (Causal Consistency)

### 冲突处理

*多个组件同时写入时如何处理？*

```go
// 乐观并发控制示例
func Update(obj *Object) error {
    for {
        current, err := Get(obj.Name)
        if err != nil {
            return err
        }

        obj.ResourceVersion = current.ResourceVersion
        err = client.Update(obj)
        if errors.IsConflict(err) {
            continue // 重试
        }
        return err
    }
}
```

*源码位置*: `path/to/file:line`

---

## Source of Truth 2: [数据名称]

...

---

## 违反 SoT 原则的代码

| 位置 | 问题 | 影响 | 修复建议 |
|:-----|:-----|:-----|:---------|
| `file:line` | 多处写入同一数据 | 数据不一致 | 统一写入点 |
| `file:line` | 缓存当作源使用 | 数据丢失风险 | 明确主从关系 |

---

## 数据同步模式

### 模式 1: Push (推送)

```
Source ──push──▶ Consumer

优点: 实时性好
缺点: 需要维护订阅关系
适用: 变更频率低，消费者少
```

### 模式 2: Pull (拉取)

```
Source ◀──pull── Consumer

优点: 消费者自主
缺点: 可能有延迟
适用: 消费者自己决定刷新频率
```

### 模式 3: Watch (监听)

```
Source ──events──▶ Consumer
       (增量变更)

优点: 实时 + 高效
缺点: 需要处理断连重连
适用: 大规模场景
```

### 本系统采用的模式

| 数据 | 同步模式 | 原因 |
|:-----|:---------|:-----|
| ... | Push/Pull/Watch | ... |

---

## 缓存策略

### Cache-Aside (旁路缓存)

```
读取: 先查缓存 → 未命中则查源 → 写入缓存 → 返回
写入: 写入源 → 删除缓存
```

### Write-Through (穿透写)

```
写入: 同时写入缓存和源
读取: 只读缓存
```

### 本系统缓存策略

| 缓存 | 策略 | 过期时间 | 失效触发 |
|:-----|:-----|:---------|:---------|
| ... | Cache-Aside | 5min | 事件驱动 |

---

## 一致性问题排查

### 常见问题

| 症状 | 可能原因 | 排查方法 |
|:-----|:---------|:---------|
| 读到旧数据 | 缓存未失效 | 检查失效逻辑 |
| 数据丢失 | 写入非源位置 | 检查写入路径 |
| 数据不一致 | 多写者冲突 | 检查并发控制 |

### 排查工具

```bash
# 比较源和缓存
diff <(get_from_source) <(get_from_cache)

# 检查版本号
get_resource_version source
get_resource_version cache
```

---

## Checklist

- [ ] 每条重要数据都能明确指出真相之源
- [ ] 所有写入都发生在真相之源
- [ ] 派生数据有明确的重建机制
- [ ] 缓存有失效/过期策略
- [ ] 并发写入有冲突检测
- [ ] 数据流向是单向的（源→派生）
