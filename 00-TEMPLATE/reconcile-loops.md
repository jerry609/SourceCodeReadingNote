# 闭环设计 (Reconcile Loops)

> 能演进的系统是控制回路：观察 → 比较 → 纠偏 → 再观察。
> 你设计的不是"做事"，而是"让现实持续逼近期望"。

## 闭环 vs 流程

| 特性 | 闭环 (Reconcile) | 流程 (Pipeline) |
|:-----|:-----------------|:----------------|
| 执行模式 | 持续运行 | 一次性执行 |
| 容错 | 天然重试 | 需要显式补偿 |
| 新增组件 | 自动适配 | 需要修改流程 |
| 迁移 | 渐进式 | 通常全量 |
| 状态 | 期望状态 + 当前状态 | 中间状态 |

---

## 核心闭环清单

| 闭环名称 | 触发方式 | 收敛周期 | 幂等性 | 源码位置 |
|:---------|:---------|:---------|:-------|:---------|
| ... | 事件/定时/手动 | 秒级/分钟级 | Yes/No | `path/to/` |

---

## Reconcile Loop 1: [名称]

### 闭环模型

```
┌─────────────────────────────────────────────────────────────────┐
│                       Reconcile Loop                            │
│                                                                 │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐ │
│   │  Observe │───▶│ Compare  │───▶│ Correct  │───▶│  Verify  │ │
│   │ (观察)   │    │ (比较)   │    │ (纠偏)   │    │ (验证)   │ │
│   └──────────┘    └──────────┘    └──────────┘    └──────────┘ │
│        ▲                                               │        │
│        └───────────────────────────────────────────────┘        │
│                         (再观察)                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 触发条件

- [ ] 资源变更事件 (Watch)
- [ ] 定时触发 (Resync)
- [ ] 手动触发 (Force Reconcile)
- [ ] 依赖资源变更

### 期望状态来源

*期望状态存储在哪里？谁可以修改？*

```yaml
# 期望状态示例
spec:
  replicas: 3
  image: nginx:1.19
```

### 当前状态获取

*如何观察当前状态？*

```go
// 观察逻辑
func (r *Reconciler) observe(ctx context.Context) (*CurrentState, error) {
    // ...
}
```

### 比较逻辑

*如何判断是否需要纠偏？*

```go
// 比较逻辑
func needsCorrection(desired, current *State) bool {
    // ...
}
```

### 纠偏动作

*执行什么动作来收敛？*

| 差异类型 | 纠偏动作 | 幂等保证 |
|:---------|:---------|:---------|
| 副本数不足 | 创建新副本 | 使用唯一名称 |
| 配置过期 | 更新配置 | 版本号比较 |
| 资源残留 | 清理资源 | 所有权检查 |

### 收敛策略

**超时处理**:
- 单次协调超时: X 秒
- 整体收敛超时: Y 分钟

**退避策略**:
```go
// 指数退避
backoff := wait.Backoff{
    Duration: 1 * time.Second,
    Factor:   2.0,
    Steps:    5,
    Cap:      1 * time.Minute,
}
```

**死信/隔离**:
*多次失败后如何处理？*

---

## Reconcile Loop 2: [名称]

...

---

## 幂等性保证

### Checklist

- [ ] 创建操作使用唯一标识符 (避免重复创建)
- [ ] 更新操作检查版本号 (避免覆盖更新)
- [ ] 删除操作检查存在性 (避免删除不存在的资源)
- [ ] 副作用操作有去重机制 (避免重复发送通知等)

### 幂等性测试

| 场景 | 输入 | 首次执行 | 重复执行 | 预期结果 |
|:-----|:-----|:---------|:---------|:---------|
| 创建 | 相同请求 | 成功创建 | 无操作 | 一个资源 |
| 更新 | 相同状态 | 成功更新 | 无操作 | 状态不变 |

---

## 失败处理

### 失败分类

| 失败类型 | 可重试 | 处理策略 |
|:---------|:-------|:---------|
| 临时错误 (网络) | Yes | 退避重试 |
| 资源冲突 | Yes | 重新获取后重试 |
| 业务错误 | No | 记录并报警 |
| 依赖不满足 | Wait | 等待依赖就绪 |

### 人工介入路径

*什么情况下需要人工介入？如何介入？*

---

## 可观测性

### 关键指标

| 指标 | 类型 | 含义 |
|:-----|:-----|:-----|
| reconcile_total | Counter | 协调总次数 |
| reconcile_duration_seconds | Histogram | 协调耗时 |
| reconcile_errors_total | Counter | 协调错误次数 |
| queue_depth | Gauge | 待协调队列深度 |

### 关键日志

```
level=info msg="Reconciling" resource=xxx/yyy
level=info msg="Correction applied" action=create target=zzz
level=error msg="Reconcile failed" error="..." retryAfter=30s
```

---

## 并发与冲突

### 并发控制

- [ ] 单资源串行协调 (Work Queue)
- [ ] 乐观并发 (ResourceVersion)
- [ ] 分布式锁 (Leader Election)

### 冲突解决

*多个协调器同时操作时如何解决？*
