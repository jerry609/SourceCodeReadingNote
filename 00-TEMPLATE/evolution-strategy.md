# 演进策略 (Evolution Strategy)

> 演进不是让核心长大，而是让生态在边缘繁荣。
> 好的演进是用户无感知的，坏的演进是让用户跟着你改代码。

## 设计原则

1. **向后兼容**: 新版本能处理旧版本的数据/API
2. **渐进式迁移**: 允许新旧版本共存，平滑过渡
3. **特性开关**: 新功能通过 Feature Gate 控制，可随时回滚
4. **版本化接口**: API 有明确版本，弃用有时间表

---

## 版本策略

### API 版本

| 版本 | 状态 | 引入时间 | 计划弃用 | 变更说明 |
|:-----|:-----|:---------|:---------|:---------|
| v1alpha1 | Alpha | ... | ... | 初始版本 |
| v1beta1 | Beta | ... | ... | 新增字段 X |
| v1 | Stable | ... | - | GA 版本 |

### 版本兼容矩阵

| 客户端版本 | 服务端 v1.0 | 服务端 v1.1 | 服务端 v2.0 |
|:-----------|:------------|:------------|:------------|
| v1.0 | ✓ | ✓ | ✓ (兼容模式) |
| v1.1 | ✓ | ✓ | ✓ |
| v2.0 | ✗ | ✓ (降级) | ✓ |

---

## Feature Gates

### 当前特性开关

| 特性名 | 默认状态 | 阶段 | 引入版本 | 说明 |
|:-------|:---------|:-----|:---------|:-----|
| FeatureA | false | Alpha | v1.20 | 描述... |
| FeatureB | true | Beta | v1.18 | 描述... |
| FeatureC | locked | GA | v1.15 | 描述... |

### 特性生命周期

```
Alpha (默认关闭) → Beta (默认开启) → GA (锁定开启) → 移除开关
     │                  │                │
     └── 可能被移除 ────┴── 最少 N 版本 ──┘
```

### 特性开关使用

```go
// 检查特性是否启用
if feature.DefaultFeatureGate.Enabled(features.FeatureA) {
    // 新功能逻辑
}
```

*源码位置*: `pkg/features/`

---

## 数据迁移

### 迁移清单

| 迁移项 | 触发条件 | 自动/手动 | 回滚支持 | 源码位置 |
|:-------|:---------|:----------|:---------|:---------|
| Schema v1→v2 | 版本升级 | 自动 | Yes | `path/to/` |

### 迁移模式

#### 模式 1: 双写迁移

```
阶段 1: 写新读旧
        ┌──────────┐
写入 ──▶│  新存储  │
   │    └──────────┘
   │    ┌──────────┐
   └───▶│  旧存储  │◀── 读取
        └──────────┘

阶段 2: 数据同步
新存储 ◀───── 批量迁移 ───── 旧存储

阶段 3: 写新读新
        ┌──────────┐
写入 ──▶│  新存储  │◀── 读取
        └──────────┘
        ┌──────────┐
        │  旧存储  │ (只读/下线)
        └──────────┘
```

#### 模式 2: 版本化存储

```go
// 读取时自动转换
func Load(data []byte) (*Object, error) {
    version := detectVersion(data)
    switch version {
    case 1:
        v1 := &ObjectV1{}
        json.Unmarshal(data, v1)
        return convertV1ToV2(v1), nil
    case 2:
        v2 := &Object{}
        json.Unmarshal(data, v2)
        return v2, nil
    }
}
```

---

## 弃用策略

### 弃用时间表

| 组件/API | 弃用版本 | 移除版本 | 替代方案 | 迁移指南 |
|:---------|:---------|:---------|:---------|:---------|
| OldAPI | v1.20 | v1.24 | NewAPI | docs/migration/... |

### 弃用公告模板

```markdown
## Deprecation Notice

**组件**: XXX
**弃用版本**: v1.20
**移除版本**: v1.24
**替代方案**: YYY

### 迁移步骤

1. ...
2. ...

### 时间线

- v1.20: 标记弃用，日志警告
- v1.22: 默认禁用，需显式启用
- v1.24: 代码移除
```

### 弃用检测

```go
// 运行时弃用警告
func (h *Handler) OldMethod() {
    klog.Warningf("OldMethod is deprecated, use NewMethod instead")
    // ...
}
```

---

## 兼容性保证

### API 兼容性规则

- [ ] 新增可选字段: 允许
- [ ] 新增必选字段: 需要版本升级
- [ ] 删除字段: 先弃用，N 个版本后移除
- [ ] 重命名字段: 新增别名，保留旧名
- [ ] 修改字段类型: 需要版本升级

### 行为兼容性

| 变更类型 | 允许? | 处理方式 |
|:---------|:------|:---------|
| 修复 Bug | 通常允许 | 记录变更 |
| 性能优化 | 允许 | 无需通知 |
| 默认值变更 | 谨慎 | Feature Gate |
| 语义变更 | 不允许 | 需要新 API |

---

## 回滚策略

### 回滚检查清单

- [ ] 数据格式是否向后兼容？
- [ ] 是否有不可逆的迁移？
- [ ] 外部依赖是否有版本要求？
- [ ] Feature Gate 是否可以关闭？

### 回滚步骤模板

```markdown
## 回滚步骤

1. 关闭 Feature Gate
2. 回滚部署
3. 验证服务正常
4. (可选) 数据回滚
```

---

## 测试策略

### 兼容性测试

| 测试类型 | 覆盖范围 | 自动化 |
|:---------|:---------|:-------|
| API 兼容性 | 所有公开 API | Yes |
| 数据兼容性 | 存储格式 | Yes |
| 升级测试 | N-1 → N 版本 | Yes |
| 降级测试 | N → N-1 版本 | Partial |

### 测试用例示例

```go
func TestBackwardCompatibility(t *testing.T) {
    // 旧版本数据
    oldData := []byte(`{"version": 1, ...}`)

    // 新版本应该能正确解析
    obj, err := Load(oldData)
    require.NoError(t, err)

    // 验证转换正确
    assert.Equal(t, expectedValue, obj.Field)
}
```

---

## 参考案例

| 系统 | 演进策略 | 特点 |
|:-----|:---------|:-----|
| Kubernetes | API 版本 + Feature Gate | 严格弃用周期 |
| gRPC | Proto 兼容性规则 | 字段编号不可复用 |
| Linux Kernel | 用户空间 ABI 不破坏 | "不破坏用户空间" |
