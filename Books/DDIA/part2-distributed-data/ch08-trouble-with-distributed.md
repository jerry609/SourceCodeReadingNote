# Chapter 8: The Trouble with Distributed Systems

> 分布式系统的麻烦 - 故障模型与不可靠性

## 核心概念

### 8.1 分布式系统 vs 单机系统

| 特性 | 单机 | 分布式 |
|:-----|:-----|:-------|
| 故障模式 | 确定性 (要么工作要么崩溃) | 部分故障 |
| 通信 | 共享内存 | 网络消息 |
| 时钟 | 单一时钟 | 多个不同步时钟 |

### 8.2 部分故障 (Partial Failure)

分布式系统的一部分可能故障，而其他部分正常工作。

## 不可靠的网络

### 网络问题

```
发送方 → [网络] → 接收方

可能发生:
1. 请求丢失
2. 请求排队延迟
3. 响应丢失
4. 响应延迟
5. 接收方崩溃
```

### 超时与重试

**问题**: 超时后无法确定请求是否被处理

**解决方案**:
- 幂等操作
- 请求去重 (唯一 ID)

### 网络分区 (Network Partition)

```
节点 A ←──×──→ 节点 B
    ↓              ↓
  正常工作      正常工作
  但互相不可达
```

## 不可靠的时钟

### 两种时钟

| 类型 | 用途 | 问题 |
|:-----|:-----|:-----|
| 物理时钟 (Time-of-Day) | 墙上时间 | NTP 同步有误差、可能回退 |
| 单调时钟 (Monotonic) | 测量时间间隔 | 只在单机有意义 |

### 时钟同步问题

```
机器 A: 10:00:00.000
机器 B: 10:00:00.500 (快 500ms)

如果用时间戳判断先后顺序，可能出错!
```

### 逻辑时钟

- **Lamport 时钟**: 事件计数器
- **向量时钟**: 因果关系追踪

## 进程暂停

### 暂停原因

- GC (垃圾回收) Stop-The-World
- 虚拟机迁移
- 系统休眠/恢复
- 同步 I/O 阻塞
- 内存交换 (Swap)

### 后果

```
节点 A 获取租约 (lease)
节点 A GC 暂停 10 秒
租约过期，节点 B 获取租约
节点 A 恢复，仍认为持有租约
两个节点同时认为自己是 Leader!
```

### 解决方案

- Fencing Token: 递增的令牌号
- 检查令牌是否仍然有效

## 知识与真相

### 拜占庭故障

节点可能撒谎、作恶

**应对**: 拜占庭容错算法 (BFT)

### 非拜占庭故障

假设节点诚实但可能崩溃

**大多数系统采用此假设**

### 系统模型

| 模型 | 假设 |
|:-----|:-----|
| 同步模型 | 有界延迟、有界时钟偏移 |
| 部分同步 | 大多数时候同步，偶尔异常 |
| 异步模型 | 无任何时间假设 |

| 故障模型 | 假设 |
|:----------|:-----|
| 崩溃-停止 | 崩溃后永不恢复 |
| 崩溃-恢复 | 崩溃后可能恢复 |
| 拜占庭 | 节点可能任意行为 |

## 要点总结

1. 网络不可靠：丢包、延迟、分区
2. 时钟不可靠：NTP 误差、回退
3. 进程可能暂停：GC、调度延迟
4. 分布式系统没有全局真相

## 思考题

- [ ] 如何区分节点崩溃和网络分区？
- [ ] 为什么不能用时间戳判断事件顺序？
- [ ] Fencing Token 如何防止脑裂？

## 源码关联

| 概念 | 相关项目 | 实现 |
|:-----|:---------|:-----|
| 超时重试 | JuiceFS | 对象存储请求重试 |
| 心跳检测 | JuiceFS | Session 心跳机制 |
| 租约 | etcd | Leader 租约 |
